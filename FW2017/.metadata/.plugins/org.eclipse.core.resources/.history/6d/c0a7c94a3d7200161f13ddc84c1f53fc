/*
 * timer.cpp
 *
 *  Created on: Sep 3, 2016
 *      Author: James
 */

#include "timer.hpp"
#include "msp.h"
#include "clocks.h"

namespace Peripherials {
Timer TA0(TIMER_A0, ACLK), TA1(TIMER_A1, ACLK), TA2(TIMER_A2, ACLK), TA3(
TIMER_A3, ACLK);

Timer::Timer(Timer_A_Type* instance, TimerClockSource source) :
		regs(*instance) {
	regs.CTL = (source & (3 << 8)) | (TACLR);
}

void Timer::SetPeriod(uint16_t period) {
	switch ((TimerClockSource) (regs.CTL >> 8) & 0x3) {
	/* umm, this is external without a fixed period, so do nothing */
	case TAxCLK:
	case INCLK:
		break;

	case ACLK:
	case SMCLK:
		/* set the period to the provided value */
		regs.CCR[0] = period;
		/* Set the mode to up (to make use of the period) */
		regs.CTL = (regs.CTL & ~(3 << 4)) | (MC__UP);
		break;
	}
}

void Timer::SetPeriod(float period) {
	switch ((TimerClockSource) (regs.CTL >> 8) & 0x3) {
	/* umm, this is external without a fixed period, so do nothing */
	case TAxCLK:
	case INCLK:
		break;

	case ACLK:
		/* set the period to the computed value */
		regs.CCR[0] = (uint16_t) ((ACLK * period) + 0.5);
		/* Set the mode to up (to make use of the period) */
		regs.CTL = (regs.CTL & ~(3 << 4)) | (MC__UP);
		break;

	case SMCLK:
		/* set the period to the computed value */
		regs.CCR[0] = (uint16_t) ((SMCLK * period) + 0.5);
		/* Set the mode to up (to make use of the period) */
		regs.CTL = (regs.CTL & ~(3 << 4)) | (MC__UP);
		break;
	}
}

void Timer::StartPWM(TimerCapComUnit module, float pulse_width) {
	switch ((TimerClockSource) (regs.CTL >> 8) & 0x3) {
	/* umm, this is external without a fixed period, so do nothing */
	case TAxCLK:
	case INCLK:
		break;

	case ACLK:
		regs.CCTL[(int) module] = CAP | OUTMOD_7;
		regs.CCR[(int) module] = (uint16_t) ((pulse_width * ACLK) + 0.5);
		break;

	case SMCLK:
		regs.CCTL[(int) module] = CAP | OUTMOD_7;
		regs.CCR[(int) module] = (uint16_t) ((pulse_width * SMCLK) + 0.5);
		break;
	}
}

void Timer::StartPWM(TimerCapComUnit module, uint16_t pulse_width) {
	switch ((TimerClockSource) (regs.CTL >> 8) & 0x3) {
	/* umm, this is external without a fixed period, so do nothing */
	case TAxCLK:
	case INCLK:
		break;

	case ACLK:
	case SMCLK:
		regs.CCTL[(int) module] = CAP | OUTMOD_7;
		regs.CCR[(int) module] = pulse_width;
		break;
	}
}

/**
 * Calls the interrupt on a timer reset (PWM mode),
 * a timer match (timer mode),
 * or a input event
 */
void AttachInterrupt(void (*new_interrupt)(void)) {

}

/**
 * Don't call this, used exclusively by library code
 */
void _CCR0_ISR(void);
/**
 * Don't call this, used exclusively by library code
 */
void _CCRn_ISR(void);

namespace {
#pragma vector=TIMER0_A0_VECTOR
__interrupt void TA0_0_IRQHandler() {
	TA0._CCR0_ISR();
}
}
}
