/*
 * uart.cpp
 *
 *  Created on: Sep 10, 2016
 *      Author: James
 */

#include "uart.hpp"
#include "clocks.h"

namespace Peripherials {

Buffers::AutoBuffer<300> A1_rawTx;
Buffers::BaseBuffer A1_txBuffer(A1_rawTx.GetData(), A1_rawTx.GetSize());
Buffers::RollingBuffer A1_txQueue(A1_txBuffer);

UART UART_A1(*EUSCI_A1, 9600, A1_txQueue);

UART::UART(EUSCI_A_Type& instance, int baud, Buffers::RollingBuffer backing) :
		regs(instance), buffer(backing) {
	regs.CTLW0 = UCPEN | UCPAR | UCMSB | (1 << 7) | UCSWRST | UCSPB;

	int N = fSMCLK/baud;
	int F = (N % 16);
	//(N/16) – (N - N % 16)

	regs.BRW = (N / 16);
	regs.CTLW0 &= ~UCSWRST;
	\regs.MCTLW = (((((N/16) – INT(N/16)) × 16) << EUSCI_A_MCTLW_BRS_OFS) | (F << EUSCI_A_MCTLW_BRF_OFS) | UCOS16;
	NVIC_EnableIRQ(EUSCIA1_IRQn);
}

void UART::Send(char c) {
	buffer.Enqueue(c);
	regs.IE |= 0x02;
}

void UART::OnInterrupt() {
	switch (regs.IV) {
	case 0:
		// no interrupt (shouldn't occur)
		break;
	case 2:
		// RX interrupt
		break;
	case 4:
		// TX empty interrupt
		if (!buffer.IsEmpty()) {
			regs.TXBUF = buffer.Dequeue();
		} else {
			regs.IE &= ~0x02;
		}
		break;
	case 8:
		// TX complete interrupt
		if (!buffer.IsEmpty()) {
			regs.TXBUF = buffer.Dequeue();
		} else {
			regs.IE &= ~0x02;
		}
		break;

	}
}

namespace {
extern "C" {
void EUSCIA1_IRQHandler() {
	UART_A1.OnInterrupt();
}
}
}
}

